<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">



<link rel="icon" type="image/ico" href="https://guides.muthu.co/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://guides.muthu.co/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://guides.muthu.co/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="https://guides.muthu.co/android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://guides.muthu.co/apple-touch-icon.png">

<meta name="description" content=""/>



<title>
    
    Beginner&#39;s Guide to Prolog | Beginner’s Guide to Programming Languages
    
</title>
<link href="/_pagefind/pagefind-ui.css" rel="stylesheet">
<script src="/_pagefind/pagefind-ui.js"></script>
<link rel="canonical" href="https://guides.muthu.co/posts/beginners-guide-to-prolog/"/>

<meta property="og:url" content="https://guides.muthu.co/posts/beginners-guide-to-prolog/">
  <meta property="og:site_name" content="Beginner’s Guide to Programming Languages">
  <meta property="og:title" content="Beginner&#39;s Guide to Prolog">
  <meta property="og:description" content="Introduction to Prolog # What is Prolog? # Prolog (Programming in Logic) is a declarative logic programming language. Unlike imperative languages (like C&#43;&#43; or Java) which specify how to solve a problem step-by-step, Prolog focuses on specifying what the problem is. You define facts and rules about a domain, and Prolog uses its built-in inference engine to deduce answers to queries based on this knowledge. This makes Prolog particularly well-suited for tasks involving symbolic computation, artificial intelligence, knowledge representation, and natural language processing. Its core mechanism involves pattern matching and unification to find solutions.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-09T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-02-09T00:00:00+00:00">













<link rel="stylesheet" href="/assets/combined.min.5015c48a8e033f524166da75d1f75528e8c05985d07019c86b8bbfd3e4213abd.css" media="all">




      <script async src="https://www.googletagmanager.com/gtag/js?id=G-78L71VCGB2"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-78L71VCGB2');
        }
      </script>




<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561" crossorigin="anonymous"></script>
</head>







<body class="light">
  <div class="content">
    <header>
      

<div class="header">

    
    <div id="search"></div>
</div>

    </header>
    <main class="main">
      





<div class="breadcrumbs">
    
    <a href="/">Home</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a href="/posts/">Posts</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a class="breadcrumbs-current" href="/posts/beginners-guide-to-prolog/">Beginner&#39;s Guide to Prolog</a>
</div>



<div >

  <div class="single-intro-container">

    

    <h1 class="single-title" data-pagefind-body>Beginner&#39;s Guide to Prolog</h1>
    

    

    <p class="single-readtime">
      
      
      
      <time datetime="2025-02-09T00:00:00&#43;00:00">February 9, 2025</time>
      

      
      &nbsp; · &nbsp;
      14 min read
      
    </p>

  </div>

  

  

  
  <aside class="toc">
    <p><strong>Table of contents</strong></p>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction-to-prolog">Introduction to Prolog</a>
      <ul>
        <li><a href="#what-is-prolog">What is Prolog?</a></li>
        <li><a href="#why-learn-prolog">Why Learn Prolog?</a></li>
        <li><a href="#setting-up-your-prolog-environment">Setting up your Prolog environment</a></li>
        <li><a href="#your-first-prolog-program">Your first Prolog program.</a></li>
      </ul>
    </li>
    <li><a href="#basic-syntax-and-concepts">Basic Syntax and Concepts</a>
      <ul>
        <li><a href="#facts">Facts</a></li>
        <li><a href="#rules">Rules</a></li>
        <li><a href="#queries">Queries</a></li>
        <li><a href="#variables">Variables</a></li>
        <li><a href="#unification">Unification</a></li>
      </ul>
    </li>
    <li><a href="#working-with-lists">Working with Lists</a>
      <ul>
        <li><a href="#list-syntax">List Syntax</a></li>
        <li><a href="#head-and-tail">Head and Tail</a></li>
        <li><a href="#common-list-operations">Common List Operations</a></li>
        <li><a href="#list-manipulation-examples">List Manipulation Examples</a></li>
      </ul>
    </li>
    <li><a href="#control-structures">Control Structures</a>
      <ul>
        <li><a href="#cut-operator-">Cut Operator (!)</a></li>
        <li><a href="#if-then-else">If-Then-Else</a></li>
        <li><a href="#recursion">Recursion</a></li>
      </ul>
    </li>
    <li><a href="#advanced-topics-optional">Advanced Topics (Optional)</a>
      <ul>
        <li><a href="#backtracking">Backtracking</a></li>
        <li><a href="#predicates-and-arguments">Predicates and Arguments</a></li>
        <li><a href="#modules">Modules</a></li>
        <li><a href="#using-libraries">Using Libraries</a></li>
      </ul>
    </li>
    <li><a href="#example-projects">Example Projects</a>
      <ul>
        <li><a href="#family-tree">Family Tree</a></li>
        <li><a href="#simple-database">Simple Database</a></li>
        <li><a href="#pathfinding">Pathfinding</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </aside>
  

  

  <div class="single-content">
    <h2 class="heading" id="introduction-to-prolog">
  Introduction to Prolog
  <a class="anchor" href="#introduction-to-prolog">#</a>
</h2>
<h3 class="heading" id="what-is-prolog">
  What is Prolog?
  <a class="anchor" href="#what-is-prolog">#</a>
</h3>
<p>Prolog (Programming in Logic) is a declarative logic programming language.  Unlike imperative languages (like C++ or Java) which specify <em>how</em> to solve a problem step-by-step, Prolog focuses on specifying <em>what</em> the problem is. You define facts and rules about a domain, and Prolog uses its built-in inference engine to deduce answers to queries based on this knowledge.  This makes Prolog particularly well-suited for tasks involving symbolic computation, artificial intelligence, knowledge representation, and natural language processing.  Its core mechanism involves pattern matching and unification to find solutions.</p>
<h3 class="heading" id="why-learn-prolog">
  Why Learn Prolog?
  <a class="anchor" href="#why-learn-prolog">#</a>
</h3>
<p>Learning Prolog offers several advantages:</p>
<ul>
<li><strong>Unique Programming Paradigm:</strong> Prolog introduces a fundamentally different way of thinking about programming, enhancing your overall problem-solving skills.  Understanding declarative programming complements procedural approaches.</li>
<li><strong>AI and Knowledge Representation:</strong> Prolog excels in representing knowledge and reasoning with it, making it a valuable tool for AI projects.</li>
<li><strong>Problem Solving with Logic:</strong>  It encourages a more logical and structured approach to problem definition and solution.</li>
<li><strong>Relatively Easy to Learn (initially):</strong>  The syntax is relatively straightforward compared to many other languages, allowing for rapid initial progress.</li>
<li><strong>Powerful Built-in Features:</strong> Prolog provides powerful built-in predicates for searching, backtracking, and list manipulation.</li>
</ul>
<h3 class="heading" id="setting-up-your-prolog-environment">
  Setting up your Prolog environment
  <a class="anchor" href="#setting-up-your-prolog-environment">#</a>
</h3>
<p>To begin programming in Prolog, you&rsquo;ll need a Prolog interpreter or compiler. Several options are freely available:</p>
<ul>
<li><strong>SWI-Prolog:</strong> A popular and widely used, free, and open-source Prolog implementation.  It&rsquo;s a good choice for beginners due to its extensive documentation and community support.  Download instructions can be found at [insert SWI-Prolog download link here].</li>
<li><strong>GNU Prolog:</strong> Another free and open-source Prolog system.  It&rsquo;s a robust option, but might have a slightly steeper learning curve than SWI-Prolog.  [insert GNU Prolog download link here]</li>
<li><strong>Visual Prolog:</strong>  A commercial Prolog system offering a visual development environment.  This is often used for more advanced applications.</li>
</ul>
<p>After downloading and installing your chosen Prolog system, you&rsquo;ll typically need to open a Prolog console or IDE to start writing and running your programs. Consult your chosen system&rsquo;s documentation for specific instructions on launching the interpreter.</p>
<h3 class="heading" id="your-first-prolog-program">
  Your first Prolog program.
  <a class="anchor" href="#your-first-prolog-program">#</a>
</h3>
<p>Let&rsquo;s write a simple Prolog program that defines facts about family relationships and then queries it.  Open your Prolog interpreter.  Type the following lines, pressing Enter after each:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">father</span>(<span style="color:#4070a0">john</span>, <span style="color:#4070a0">mary</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">father</span>(<span style="color:#4070a0">john</span>, <span style="color:#4070a0">peter</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">mother</span>(<span style="color:#4070a0">jane</span>, <span style="color:#4070a0">mary</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">mother</span>(<span style="color:#4070a0">jane</span>, <span style="color:#4070a0">peter</span>).
</span></span></code></pre></div><p>These lines define facts.  <code>father(john, mary).</code> states that John is the father of Mary.  Now, let&rsquo;s ask a question:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">father</span>(<span style="color:#4070a0">john</span>, <span style="color:#4070a0">mary</span>).
</span></span></code></pre></div><p>Press Enter.  Prolog will respond with:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#4070a0">true</span>.
</span></span></code></pre></div><p>This indicates that the fact is true based on the knowledge base you provided.  Try other queries, such as:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">mother</span>(<span style="color:#4070a0">jane</span>, <span style="color:#bb60d5">X</span>).
</span></span></code></pre></div><p>This will find all values of X for which Jane is the mother.  Prolog will respond with:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#bb60d5">X</span> <span style="color:#666">=</span> <span style="color:#4070a0">mary</span> ;
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">X</span> <span style="color:#666">=</span> <span style="color:#4070a0">peter</span>.
</span></span></code></pre></div><p>The semicolon (;) allows you to see alternative solutions.  Type a semicolon to see the next solution, or type a full stop (.) to finish the query. This simple example demonstrates how Prolog uses facts and queries to deduce information.  We will explore more complex examples in the following chapters.</p>
<h2 class="heading" id="basic-syntax-and-concepts">
  Basic Syntax and Concepts
  <a class="anchor" href="#basic-syntax-and-concepts">#</a>
</h2>
<h3 class="heading" id="facts">
  Facts
  <a class="anchor" href="#facts">#</a>
</h3>
<p>Facts are the fundamental building blocks of Prolog programs. They represent statements about the world that are considered to be true.  A fact consists of a predicate followed by a list of arguments enclosed in parentheses.  The arguments represent the objects involved in the relationship described by the predicate.  Facts always end with a period (<code>.</code>).</p>
<p><strong>Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">likes</span>(<span style="color:#4070a0">john</span>, <span style="color:#4070a0">apples</span>).  <span style="color:#60a0b0;font-style:italic">% John likes apples.</span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">is_a</span>(<span style="color:#4070a0">dog</span>, <span style="color:#4070a0">mammal</span>).    <span style="color:#60a0b0;font-style:italic">% A dog is a mammal.</span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">age</span>(<span style="color:#4070a0">mary</span>, <span style="color:#40a070">30</span>).       <span style="color:#60a0b0;font-style:italic">% Mary&#39;s age is 30.</span>
</span></span></code></pre></div><p>In these examples, <code>likes</code>, <code>is_a</code>, and <code>age</code> are predicates, and the terms within the parentheses are the arguments.  Predicates are essentially names for relationships, and their choice is up to the programmer, although meaningful names improve code readability.</p>
<h3 class="heading" id="rules">
  Rules
  <a class="anchor" href="#rules">#</a>
</h3>
<p>Rules express conditional relationships. They state that something is true if certain conditions are met.  A rule consists of a head and a body, separated by <code>:-</code>.  The head is what the rule concludes, and the body specifies the conditions that must be true for the head to be true.</p>
<p><strong>Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">parent</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>) :- <span style="color:#06287e">father</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">parent</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>) :- <span style="color:#06287e">mother</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>).
</span></span></code></pre></div><p>This defines <code>parent(X, Y)</code> to be true if either <code>father(X, Y)</code> is true or <code>mother(X, Y)</code> is true.  <code>X</code> and <code>Y</code> are variables (explained below).</p>
<p>Another example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">likes_fruit</span>(<span style="color:#bb60d5">Person</span>) :- <span style="color:#06287e">likes</span>(<span style="color:#bb60d5">Person</span>, <span style="color:#bb60d5">Fruit</span>), <span style="color:#06287e">is_fruit</span>(<span style="color:#bb60d5">Fruit</span>).
</span></span></code></pre></div><p>This rule states that a <code>Person</code> likes fruit if they like a specific <code>Fruit</code> and that <code>Fruit</code> is indeed a fruit.</p>
<h3 class="heading" id="queries">
  Queries
  <a class="anchor" href="#queries">#</a>
</h3>
<p>Queries are questions posed to the Prolog system.  They have the same syntax as the head of a rule, but they are preceded by <code>?-</code>.  Prolog attempts to find solutions that satisfy the query based on the facts and rules in the knowledge base.</p>
<p><strong>Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">likes</span>(<span style="color:#4070a0">john</span>, <span style="color:#4070a0">apples</span>).  <span style="color:#60a0b0;font-style:italic">% Is it true that John likes apples?</span>
</span></span><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">parent</span>(<span style="color:#4070a0">john</span>, <span style="color:#4070a0">mary</span>).   <span style="color:#60a0b0;font-style:italic">% Is John a parent of Mary?</span>
</span></span><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">parent</span>(<span style="color:#bb60d5">X</span>, <span style="color:#4070a0">mary</span>).     <span style="color:#60a0b0;font-style:italic">% Who is a parent of Mary? (X is a variable)</span>
</span></span></code></pre></div><p>Prolog will respond with <code>true.</code> if it finds a solution, <code>false.</code> if not, or a series of solutions if multiple are possible, separated by <code>;</code> (semicolons).</p>
<h3 class="heading" id="variables">
  Variables
  <a class="anchor" href="#variables">#</a>
</h3>
<p>Variables in Prolog are represented by uppercase letters or underscore followed by letters, numbers, and underscores (<code>_</code>, <code>X</code>, <code>Y</code>, <code>Person</code>, <code>_age</code>).  They act as placeholders for values that Prolog will try to find during the unification process.</p>
<p><strong>Example:</strong> (from the previous rules section)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">parent</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>) :- <span style="color:#06287e">father</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>).
</span></span></code></pre></div><p>Here, <code>X</code> and <code>Y</code> are variables.  When the <code>parent</code> predicate is queried, Prolog will try to find values for <code>X</code> and <code>Y</code> that satisfy the condition <code>father(X, Y)</code>.</p>
<h3 class="heading" id="unification">
  Unification
  <a class="anchor" href="#unification">#</a>
</h3>
<p>Unification is the core mechanism of Prolog. It&rsquo;s the process of matching terms (facts, rule heads, query goals, and sub-goals within rules).  It involves assigning values to variables to make two terms identical.</p>
<p><strong>Example:</strong></p>
<p>Consider the fact <code>likes(john, apples).</code> and the query <code>?- likes(john, X).</code>.  Unification will attempt to match these two.  It will successfully unify the terms by assigning the value <code>apples</code> to the variable <code>X</code>.</p>
<p>Unification involves several steps:</p>
<ol>
<li><strong>Variable Binding:</strong> Assigning a value to a variable.  Once a variable is bound to a value, that binding remains consistent within the scope of that query or rule execution.</li>
<li><strong>Term Equality:</strong>  Comparing the structure and values of terms.  Only terms with the same predicate and arguments of corresponding types can unify.</li>
<li><strong>Backtracking:</strong>  If multiple possible unifications exist, Prolog will try each one sequentially.  If a unification path leads to failure, Prolog backtracks to explore other possibilities.</li>
</ol>
<p>Unification is fundamental to how Prolog searches and infers solutions to your queries. Understanding this process is crucial for writing effective Prolog programs.</p>
<h2 class="heading" id="working-with-lists">
  Working with Lists
  <a class="anchor" href="#working-with-lists">#</a>
</h2>
<h3 class="heading" id="list-syntax">
  List Syntax
  <a class="anchor" href="#list-syntax">#</a>
</h3>
<p>Lists are fundamental data structures in Prolog, used to represent sequences of elements.  A list is denoted by square brackets <code>[]</code> and elements are separated by commas <code>,</code>.  An empty list is represented by <code>[]</code>.</p>
<p><strong>Examples:</strong></p>
<ul>
<li><code>[1, 2, 3]</code> : A list containing the numbers 1, 2, and 3.</li>
<li><code>[a, b, c, d]</code> : A list of characters.</li>
<li><code>[apple, banana, orange]</code> : A list of strings.</li>
<li><code>[1, [2, 3], 4]</code> : A list containing nested lists.</li>
</ul>
<h3 class="heading" id="head-and-tail">
  Head and Tail
  <a class="anchor" href="#head-and-tail">#</a>
</h3>
<p>A crucial concept in Prolog list processing is the distinction between the <em>head</em> and the <em>tail</em> of a list.</p>
<ul>
<li><strong>Head:</strong> The first element of a non-empty list.</li>
<li><strong>Tail:</strong> The remaining part of the list (excluding the head). It is itself a list.</li>
</ul>
<p><strong>Example:</strong></p>
<p>For the list <code>[a, b, c]</code>:</p>
<ul>
<li>The head is <code>a</code>.</li>
<li>The tail is <code>[b, c]</code>.</li>
</ul>
<p>The notation <code>[Head|Tail]</code> is used to represent a list where <code>Head</code> is the first element and <code>Tail</code> is the rest.</p>
<h3 class="heading" id="common-list-operations">
  Common List Operations
  <a class="anchor" href="#common-list-operations">#</a>
</h3>
<p>Prolog provides built-in predicates for common list operations.  Here are some of the most important:</p>
<ul>
<li><strong><code>member(X, List)</code>:</strong>  Succeeds if <code>X</code> is a member of <code>List</code>.</li>
<li><strong><code>append(List1, List2, List3)</code>:</strong>  Succeeds if <code>List3</code> is the concatenation of <code>List1</code> and <code>List2</code>.</li>
<li><strong><code>length(List, Length)</code>:</strong>  Unifies <code>Length</code> with the number of elements in <code>List</code>.</li>
<li><strong><code>reverse(List1, List2)</code>:</strong>  Unifies <code>List2</code> with the reverse of <code>List1</code>.</li>
</ul>
<h3 class="heading" id="list-manipulation-examples">
  List Manipulation Examples
  <a class="anchor" href="#list-manipulation-examples">#</a>
</h3>
<p><strong>1. Membership:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">member</span>(<span style="color:#40a070">2</span>, [<span style="color:#40a070">1</span>, <span style="color:#40a070">2</span>, <span style="color:#40a070">3</span>]).
</span></span><span style="display:flex;"><span><span style="color:#4070a0">true</span>.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">member</span>(<span style="color:#40a070">4</span>, [<span style="color:#40a070">1</span>, <span style="color:#40a070">2</span>, <span style="color:#40a070">3</span>]).
</span></span><span style="display:flex;"><span><span style="color:#4070a0">false</span>.
</span></span></code></pre></div><p><strong>2. Append:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">append</span>([<span style="color:#40a070">1</span>, <span style="color:#40a070">2</span>], [<span style="color:#40a070">3</span>, <span style="color:#40a070">4</span>], <span style="color:#bb60d5">X</span>).
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">X</span> <span style="color:#666">=</span> [<span style="color:#40a070">1</span>, <span style="color:#40a070">2</span>, <span style="color:#40a070">3</span>, <span style="color:#40a070">4</span>].
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">append</span>(<span style="color:#bb60d5">X</span>, [<span style="color:#40a070">3</span>, <span style="color:#40a070">4</span>], [<span style="color:#40a070">1</span>, <span style="color:#40a070">2</span>, <span style="color:#40a070">3</span>, <span style="color:#40a070">4</span>]).
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">X</span> <span style="color:#666">=</span> [<span style="color:#40a070">1</span>, <span style="color:#40a070">2</span>].
</span></span></code></pre></div><p><strong>3. Length:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">length</span>([<span style="color:#4070a0">a</span>, <span style="color:#4070a0">b</span>, <span style="color:#4070a0">c</span>], <span style="color:#bb60d5">L</span>).
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">L</span> <span style="color:#666">=</span> <span style="color:#40a070">3.</span>
</span></span></code></pre></div><p><strong>4. Reverse:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">reverse</span>([<span style="color:#40a070">1</span>, <span style="color:#40a070">2</span>, <span style="color:#40a070">3</span>], <span style="color:#bb60d5">X</span>).
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">X</span> <span style="color:#666">=</span> [<span style="color:#40a070">3</span>, <span style="color:#40a070">2</span>, <span style="color:#40a070">1</span>].
</span></span></code></pre></div><p><strong>5. Custom Predicate (Summing List Elements):</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">sum_list</span>([], <span style="color:#40a070">0</span>).  <span style="color:#60a0b0;font-style:italic">% Base case: empty list sums to 0</span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">sum_list</span>([<span style="color:#bb60d5">Head</span>|<span style="color:#bb60d5">Tail</span>], <span style="color:#bb60d5">Sum</span>) :-
</span></span><span style="display:flex;"><span>    <span style="color:#06287e">sum_list</span>(<span style="color:#bb60d5">Tail</span>, <span style="color:#bb60d5">SubSum</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#bb60d5">Sum</span> <span style="color:#666">is</span> <span style="color:#bb60d5">Head</span> <span style="color:#666">+</span> <span style="color:#bb60d5">SubSum</span>.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">sum_list</span>([<span style="color:#40a070">1</span>, <span style="color:#40a070">2</span>, <span style="color:#40a070">3</span>, <span style="color:#40a070">4</span>], <span style="color:#bb60d5">Sum</span>).
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">Sum</span> <span style="color:#666">=</span> <span style="color:#40a070">10.</span>
</span></span></code></pre></div><p>This example demonstrates recursion, a common technique for processing lists in Prolog.  The <code>sum_list</code> predicate recursively calculates the sum of elements in a list.  The base case handles the empty list, and the recursive case adds the head to the sum of the tail.  These examples illustrate the power and flexibility of lists in Prolog programming.  Many more complex list manipulations can be built upon these foundational operations.</p>
<h2 class="heading" id="control-structures">
  Control Structures
  <a class="anchor" href="#control-structures">#</a>
</h2>
<h3 class="heading" id="cut-operator-">
  Cut Operator (!)
  <a class="anchor" href="#cut-operator-">#</a>
</h3>
<p>The cut operator, written as <code>!</code>, is a powerful control structure in Prolog. It affects the backtracking mechanism.  When a cut is encountered during execution:</p>
<ol>
<li><strong>Commit:</strong>  All choice points created since the rule&rsquo;s invocation are removed. This means Prolog will not backtrack to explore alternative solutions within the current rule.</li>
<li><strong>Proceed:</strong> Execution continues normally after the cut.</li>
</ol>
<p><strong>Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">member</span>(<span style="color:#bb60d5">X</span>, [<span style="color:#bb60d5">X</span>|<span style="color:#007020;font-weight:bold">_</span>]).
</span></span><span style="display:flex;"><span><span style="color:#06287e">member</span>(<span style="color:#bb60d5">X</span>, [<span style="color:#007020;font-weight:bold">_</span>|<span style="color:#bb60d5">Tail</span>]) :- <span style="color:#06287e">member</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Tail</span>).
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">fast_member</span>(<span style="color:#bb60d5">X</span>, [<span style="color:#bb60d5">X</span>|<span style="color:#007020;font-weight:bold">_</span>]):- !. <span style="color:#60a0b0;font-style:italic">%If X is the head, don&#39;t explore the tail</span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">fast_member</span>(<span style="color:#bb60d5">X</span>, [<span style="color:#007020;font-weight:bold">_</span>|<span style="color:#bb60d5">Tail</span>]) :- <span style="color:#06287e">fast_member</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Tail</span>).
</span></span></code></pre></div><p><code>member/2</code> is a standard Prolog predicate that checks for membership in a list.  <code>fast_member/2</code> uses a cut to optimize the search. If the element <code>X</code> is found as the head of the list, the cut prevents Prolog from checking the tail, making it more efficient when the element is at the beginning. Without the cut,  <code>member/2</code> would continue to search even after finding a match, especially relevant for larger lists.  However, overuse of cuts can lead to unintended consequences, so use them judiciously.</p>
<h3 class="heading" id="if-then-else">
  If-Then-Else
  <a class="anchor" href="#if-then-else">#</a>
</h3>
<p>Prolog doesn&rsquo;t have explicit <code>if-then-else</code> constructs in the same way as imperative languages.  However, you can achieve similar functionality using the following techniques:</p>
<p><strong>1. Using <code>;</code> (semicolon) for &ldquo;if-then-else&rdquo;:</strong></p>
<p>The semicolon acts as a disjunction (OR). The first goal that succeeds determines the path of execution.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">check_age</span>(<span style="color:#bb60d5">Age</span>, <span style="color:#bb60d5">Message</span>) :-
</span></span><span style="display:flex;"><span>    <span style="color:#bb60d5">Age</span> <span style="color:#666">&gt;=</span> <span style="color:#40a070">18</span>, !,
</span></span><span style="display:flex;"><span>    <span style="color:#bb60d5">Message</span> <span style="color:#666">=</span> <span style="color:#4070a0">&#39;Adult&#39;</span>.
</span></span><span style="display:flex;"><span><span style="color:#06287e">check_age</span>(<span style="color:#007020;font-weight:bold">_</span>, <span style="color:#bb60d5">Message</span>) :-
</span></span><span style="display:flex;"><span>    <span style="color:#bb60d5">Message</span> <span style="color:#666">=</span> <span style="color:#4070a0">&#39;Minor&#39;</span>.
</span></span></code></pre></div><p>This code checks the age. If <code>Age</code> is greater than or equal to 18, it assigns &lsquo;Adult&rsquo; to <code>Message</code> and the cut (<code>!</code>) prevents checking the second condition. Otherwise, it assigns &lsquo;Minor&rsquo;.</p>
<p><strong>2. Using conditional goals:</strong></p>
<p>You can embed conditions directly within a rule&rsquo;s body using logical operators like <code>,</code> (and) and <code>;</code> (or) alongside predicates that check for conditions.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">grade</span>(<span style="color:#bb60d5">Score</span>, <span style="color:#bb60d5">Grade</span>) :-
</span></span><span style="display:flex;"><span>    <span style="color:#bb60d5">Score</span> <span style="color:#666">&gt;=</span> <span style="color:#40a070">90</span>, <span style="color:#bb60d5">Grade</span> <span style="color:#666">=</span> <span style="color:#4070a0">&#39;A&#39;</span>.
</span></span><span style="display:flex;"><span><span style="color:#06287e">grade</span>(<span style="color:#bb60d5">Score</span>, <span style="color:#bb60d5">Grade</span>) :-
</span></span><span style="display:flex;"><span>    <span style="color:#bb60d5">Score</span> <span style="color:#666">&gt;=</span> <span style="color:#40a070">80</span>, <span style="color:#bb60d5">Score</span> <span style="color:#666">&lt;</span> <span style="color:#40a070">90</span>, <span style="color:#bb60d5">Grade</span> <span style="color:#666">=</span> <span style="color:#4070a0">&#39;B&#39;</span>.
</span></span><span style="display:flex;"><span><span style="color:#06287e">grade</span>(<span style="color:#bb60d5">Score</span>, <span style="color:#bb60d5">Grade</span>) :-
</span></span><span style="display:flex;"><span>    <span style="color:#bb60d5">Score</span> <span style="color:#666">&gt;=</span> <span style="color:#40a070">70</span>, <span style="color:#bb60d5">Score</span> <span style="color:#666">&lt;</span> <span style="color:#40a070">80</span>, <span style="color:#bb60d5">Grade</span> <span style="color:#666">=</span> <span style="color:#4070a0">&#39;C&#39;</span>.
</span></span><span style="display:flex;"><span><span style="color:#06287e">grade</span>(<span style="color:#bb60d5">Score</span>, <span style="color:#bb60d5">Grade</span>) :-
</span></span><span style="display:flex;"><span>    <span style="color:#bb60d5">Score</span> <span style="color:#666">&lt;</span> <span style="color:#40a070">70</span>, <span style="color:#bb60d5">Grade</span> <span style="color:#666">=</span> <span style="color:#4070a0">&#39;F&#39;</span>.
</span></span></code></pre></div><p>This defines a <code>grade/2</code> predicate to determine letter grades based on numerical scores. The <code>Score</code> value will only unify with one rule&rsquo;s conditions.</p>
<h3 class="heading" id="recursion">
  Recursion
  <a class="anchor" href="#recursion">#</a>
</h3>
<p>Recursion is a fundamental control structure in Prolog, particularly useful for processing lists and trees.  A recursive predicate calls itself within its own definition.  It must have a base case (a condition that stops the recursion) to avoid infinite loops.</p>
<p><strong>Example (factorial):</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">factorial</span>(<span style="color:#40a070">0</span>, <span style="color:#40a070">1</span>).    <span style="color:#60a0b0;font-style:italic">% Base case: factorial of 0 is 1</span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">factorial</span>(<span style="color:#bb60d5">N</span>, <span style="color:#bb60d5">Result</span>) :-
</span></span><span style="display:flex;"><span>    <span style="color:#bb60d5">N</span> <span style="color:#666">&gt;</span> <span style="color:#40a070">0</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#bb60d5">N1</span> <span style="color:#666">is</span> <span style="color:#bb60d5">N</span> <span style="color:#666">-</span> <span style="color:#40a070">1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#06287e">factorial</span>(<span style="color:#bb60d5">N1</span>, <span style="color:#bb60d5">Result1</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#bb60d5">Result</span> <span style="color:#666">is</span> <span style="color:#bb60d5">N</span> <span style="color:#666">*</span> <span style="color:#bb60d5">Result1</span>.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">factorial</span>(<span style="color:#40a070">5</span>, <span style="color:#bb60d5">X</span>).
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">X</span> <span style="color:#666">=</span> <span style="color:#40a070">120.</span>
</span></span></code></pre></div><p>This predicate calculates the factorial of a number.  The base case handles <code>N = 0</code>.  The recursive case calculates the factorial of <code>N-1</code> and multiplies it by <code>N</code>.</p>
<p>Recursion is a powerful tool for elegant and concise solutions in Prolog, but it is essential to carefully design the base case to prevent stack overflow errors.  Efficient base cases and clear recursive steps are vital for robust recursive predicates.</p>
<h2 class="heading" id="advanced-topics-optional">
  Advanced Topics (Optional)
  <a class="anchor" href="#advanced-topics-optional">#</a>
</h2>
<h3 class="heading" id="backtracking">
  Backtracking
  <a class="anchor" href="#backtracking">#</a>
</h3>
<p>Backtracking is Prolog&rsquo;s fundamental search mechanism. When a goal fails, Prolog automatically &ldquo;undoes&rdquo; the choices made since the goal was called and tries alternative solutions.  This is crucial for finding all possible solutions to a query, especially when dealing with multiple rules or recursive predicates.</p>
<p>Consider the following example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">likes</span>(<span style="color:#4070a0">john</span>, <span style="color:#4070a0">apples</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">likes</span>(<span style="color:#4070a0">john</span>, <span style="color:#4070a0">bananas</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">likes</span>(<span style="color:#4070a0">john</span>, <span style="color:#4070a0">oranges</span>).
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">likes_fruit</span>(<span style="color:#4070a0">john</span>, <span style="color:#bb60d5">Fruit</span>):- <span style="color:#06287e">likes</span>(<span style="color:#4070a0">john</span>, <span style="color:#bb60d5">Fruit</span>).
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">likes_fruit</span>(<span style="color:#4070a0">john</span>, <span style="color:#bb60d5">Fruit</span>).
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">Fruit</span> <span style="color:#666">=</span> <span style="color:#4070a0">apples</span> ;
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">Fruit</span> <span style="color:#666">=</span> <span style="color:#4070a0">bananas</span> ;
</span></span><span style="display:flex;"><span><span style="color:#bb60d5">Fruit</span> <span style="color:#666">=</span> <span style="color:#4070a0">oranges</span>.
</span></span></code></pre></div><p>When querying <code>likes_fruit(john, Fruit)</code>, Prolog first tries to unify <code>likes(john, Fruit)</code> with <code>likes(john, apples)</code>.  If this succeeds, it finds a solution (<code>Fruit = apples</code>).  The semicolon (<code>;</code>) prompts Prolog to backtrack: it undoes the unification and tries the next possible unification—<code>likes(john, bananas)</code>. This continues until all solutions have been found.  The backtracking mechanism is transparent and automatic in most cases, but understanding how it works is important for debugging and writing efficient Prolog code.</p>
<h3 class="heading" id="predicates-and-arguments">
  Predicates and Arguments
  <a class="anchor" href="#predicates-and-arguments">#</a>
</h3>
<p>A Prolog predicate is a named relationship between objects (represented as arguments). The predicate&rsquo;s name defines the relationship, while the arguments specify the participating objects.</p>
<p>The arity of a predicate is the number of arguments it takes.  <code>likes(john, apples)</code> is a predicate with arity 2 (two arguments).  <code>age(mary, 30)</code> also has arity 2.  <code>fact(a, b, c, d)</code> has arity 4.</p>
<p>The arguments can be constants, variables, or structures (including lists).  The order of arguments is significant; changing the order alters the meaning of the predicate.  Proper naming conventions for predicates (e.g., using meaningful names, following consistent capitalization) are essential for code readability and maintainability.</p>
<h3 class="heading" id="modules">
  Modules
  <a class="anchor" href="#modules">#</a>
</h3>
<p>Modules provide a mechanism for organizing large Prolog programs.  They allow you to create separate namespaces for predicates, preventing naming conflicts and improving code modularity.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span>:- <span style="color:#06287e">module</span>(<span style="color:#4070a0">my_module</span>, [<span style="color:#4070a0">my_predicate</span><span style="color:#666">/</span><span style="color:#40a070">1</span>]).
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">my_predicate</span>(<span style="color:#bb60d5">X</span>):- <span style="color:#06287e">writeln</span>(<span style="color:#bb60d5">X</span>).
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>:- <span style="color:#4070a0">end_module</span>.
</span></span></code></pre></div><p>This code defines a module <code>my_module</code> containing a predicate <code>my_predicate/1</code>.  The <code>:- module(...)</code> declaration introduces the module.  Predicates within the module are only accessible using the module&rsquo;s name: <code>my_module:my_predicate(X)</code>.  Modules promote code reusability and prevent accidental overwriting of predicate definitions.</p>
<h3 class="heading" id="using-libraries">
  Using Libraries
  <a class="anchor" href="#using-libraries">#</a>
</h3>
<p>Prolog systems usually provide libraries of pre-written predicates for various tasks (e.g., string manipulation, I/O operations, arithmetic).  You can use these libraries to avoid re-implementing common functions.  How to import and use libraries depends on your specific Prolog system (e.g., SWI-Prolog&rsquo;s <code>use_module</code> directive).  Consult your Prolog system&rsquo;s documentation for details on available libraries and their usage.  For example, in SWI-Prolog you might use <code>use_module(library(lists)).</code> to load the <code>lists</code> library which provides additional predicates for list manipulation.  Leveraging pre-built libraries can significantly speed up development and improve code quality.</p>
<h2 class="heading" id="example-projects">
  Example Projects
  <a class="anchor" href="#example-projects">#</a>
</h2>
<h3 class="heading" id="family-tree">
  Family Tree
  <a class="anchor" href="#family-tree">#</a>
</h3>
<p>This project demonstrates representing family relationships using Prolog facts and rules.  We&rsquo;ll define facts to represent parentage, and rules to deduce other relationships like siblings and ancestry.</p>
<p><strong>Facts:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">parent</span>(<span style="color:#4070a0">john</span>, <span style="color:#4070a0">mary</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">parent</span>(<span style="color:#4070a0">john</span>, <span style="color:#4070a0">peter</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">parent</span>(<span style="color:#4070a0">jane</span>, <span style="color:#4070a0">mary</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">parent</span>(<span style="color:#4070a0">jane</span>, <span style="color:#4070a0">peter</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">parent</span>(<span style="color:#4070a0">mary</span>, <span style="color:#4070a0">anna</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">parent</span>(<span style="color:#4070a0">peter</span>, <span style="color:#4070a0">bob</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">male</span>(<span style="color:#4070a0">john</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">male</span>(<span style="color:#4070a0">peter</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">male</span>(<span style="color:#4070a0">bob</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">female</span>(<span style="color:#4070a0">jane</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">female</span>(<span style="color:#4070a0">mary</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">female</span>(<span style="color:#4070a0">anna</span>).
</span></span></code></pre></div><p><strong>Rules:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">father</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>) :- <span style="color:#06287e">parent</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>), <span style="color:#06287e">male</span>(<span style="color:#bb60d5">X</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">mother</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>) :- <span style="color:#06287e">parent</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>), <span style="color:#06287e">female</span>(<span style="color:#bb60d5">X</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">sibling</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>) :- <span style="color:#06287e">parent</span>(<span style="color:#bb60d5">P</span>, <span style="color:#bb60d5">X</span>), <span style="color:#06287e">parent</span>(<span style="color:#bb60d5">P</span>, <span style="color:#bb60d5">Y</span>), <span style="color:#bb60d5">X</span> <span style="color:#4070a0">\=</span> <span style="color:#bb60d5">Y</span>. <span style="color:#60a0b0;font-style:italic">% \= means &#34;not equal to&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">ancestor</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>) :- <span style="color:#06287e">parent</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">ancestor</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Y</span>) :- <span style="color:#06287e">parent</span>(<span style="color:#bb60d5">X</span>, <span style="color:#bb60d5">Z</span>), <span style="color:#06287e">ancestor</span>(<span style="color:#bb60d5">Z</span>, <span style="color:#bb60d5">Y</span>).
</span></span></code></pre></div><p><strong>Queries:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">father</span>(<span style="color:#4070a0">john</span>, <span style="color:#bb60d5">X</span>). <span style="color:#60a0b0;font-style:italic">%Find children of John</span>
</span></span><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">sibling</span>(<span style="color:#4070a0">mary</span>, <span style="color:#4070a0">peter</span>). <span style="color:#60a0b0;font-style:italic">%Are Mary and Peter siblings?</span>
</span></span><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">ancestor</span>(<span style="color:#4070a0">john</span>, <span style="color:#4070a0">anna</span>). <span style="color:#60a0b0;font-style:italic">%Is John an ancestor of Anna?</span>
</span></span></code></pre></div><p>This example illustrates how to represent complex relationships using facts and rules, allowing for flexible querying and inference.</p>
<h3 class="heading" id="simple-database">
  Simple Database
  <a class="anchor" href="#simple-database">#</a>
</h3>
<p>This project shows how to represent a simple database in Prolog. We&rsquo;ll create a database of books with their titles, authors, and publication years.</p>
<p><strong>Facts:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">book</span>( <span style="color:#4070a0">&#39;The Lord of the Rings&#39;</span>, <span style="color:#4070a0">&#39;J.R.R. Tolkien&#39;</span>, <span style="color:#40a070">1954</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">book</span>( <span style="color:#4070a0">&#39;Pride and Prejudice&#39;</span>, <span style="color:#4070a0">&#39;Jane Austen&#39;</span>, <span style="color:#40a070">1813</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">book</span>( <span style="color:#4070a0">&#39;1984&#39;</span>, <span style="color:#4070a0">&#39;George Orwell&#39;</span>, <span style="color:#40a070">1949</span>).
</span></span></code></pre></div><p><strong>Rules:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">author_of</span>(<span style="color:#bb60d5">Author</span>, <span style="color:#bb60d5">Title</span>) :- <span style="color:#06287e">book</span>(<span style="color:#bb60d5">Title</span>, <span style="color:#bb60d5">Author</span>, <span style="color:#007020;font-weight:bold">_</span>). <span style="color:#60a0b0;font-style:italic">%The underscore (_) ignores the year.</span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">published_in</span>(<span style="color:#bb60d5">Title</span>, <span style="color:#bb60d5">Year</span>) :- <span style="color:#06287e">book</span>(<span style="color:#bb60d5">Title</span>, <span style="color:#007020;font-weight:bold">_</span>, <span style="color:#bb60d5">Year</span>).
</span></span></code></pre></div><p><strong>Queries:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">author_of</span>(<span style="color:#4070a0">&#39;Jane Austen&#39;</span>, <span style="color:#bb60d5">Title</span>).  <span style="color:#60a0b0;font-style:italic">%Find books by Jane Austen</span>
</span></span><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">published_in</span>(<span style="color:#bb60d5">Title</span>, <span style="color:#40a070">1949</span>).      <span style="color:#60a0b0;font-style:italic">%Find books published in 1949</span>
</span></span><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">book</span>(<span style="color:#bb60d5">Title</span>, <span style="color:#bb60d5">Author</span>, <span style="color:#bb60d5">Year</span>).   <span style="color:#60a0b0;font-style:italic">% List all books with details</span>
</span></span></code></pre></div><p>This example showcases using Prolog to query and manipulate data, akin to a relational database.</p>
<h3 class="heading" id="pathfinding">
  Pathfinding
  <a class="anchor" href="#pathfinding">#</a>
</h3>
<p>This project demonstrates a simple pathfinding algorithm using Prolog. We&rsquo;ll represent a graph as facts, and use recursive rules to find a path between two nodes.</p>
<p><strong>Facts (Graph representation):</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">connected</span>(<span style="color:#4070a0">a</span>, <span style="color:#4070a0">b</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">connected</span>(<span style="color:#4070a0">a</span>, <span style="color:#4070a0">c</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">connected</span>(<span style="color:#4070a0">b</span>, <span style="color:#4070a0">d</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">connected</span>(<span style="color:#4070a0">c</span>, <span style="color:#4070a0">e</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">connected</span>(<span style="color:#4070a0">d</span>, <span style="color:#4070a0">f</span>).
</span></span><span style="display:flex;"><span><span style="color:#06287e">connected</span>(<span style="color:#4070a0">e</span>, <span style="color:#4070a0">f</span>).
</span></span></code></pre></div><p><strong>Rules (Pathfinding):</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#06287e">path</span>(<span style="color:#bb60d5">Start</span>, <span style="color:#bb60d5">End</span>, <span style="color:#bb60d5">Path</span>) :-
</span></span><span style="display:flex;"><span>    <span style="color:#06287e">path</span>(<span style="color:#bb60d5">Start</span>, <span style="color:#bb60d5">End</span>, [<span style="color:#bb60d5">Start</span>], <span style="color:#bb60d5">Path</span>).
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">path</span>(<span style="color:#bb60d5">Node</span>, <span style="color:#bb60d5">End</span>, <span style="color:#bb60d5">Visited</span>, [<span style="color:#bb60d5">End</span>|<span style="color:#bb60d5">Visited</span>]) :-
</span></span><span style="display:flex;"><span>    <span style="color:#06287e">connected</span>(<span style="color:#bb60d5">Node</span>, <span style="color:#bb60d5">End</span>).
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#06287e">path</span>(<span style="color:#bb60d5">Node</span>, <span style="color:#bb60d5">End</span>, <span style="color:#bb60d5">Visited</span>, <span style="color:#bb60d5">Path</span>) :-
</span></span><span style="display:flex;"><span>    <span style="color:#06287e">connected</span>(<span style="color:#bb60d5">Node</span>, <span style="color:#bb60d5">Next</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#4070a0">\+</span> <span style="color:#06287e">member</span>(<span style="color:#bb60d5">Next</span>, <span style="color:#bb60d5">Visited</span>),  <span style="color:#60a0b0;font-style:italic">%Check if Next is not already visited</span>
</span></span><span style="display:flex;"><span>    <span style="color:#06287e">path</span>(<span style="color:#bb60d5">Next</span>, <span style="color:#bb60d5">End</span>, [<span style="color:#bb60d5">Next</span>|<span style="color:#bb60d5">Visited</span>], <span style="color:#bb60d5">Path</span>).
</span></span></code></pre></div><p><strong>Query:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-prolog" data-lang="prolog"><span style="display:flex;"><span><span style="color:#4070a0">?-</span> <span style="color:#06287e">path</span>(<span style="color:#4070a0">a</span>, <span style="color:#4070a0">f</span>, <span style="color:#bb60d5">Path</span>). <span style="color:#60a0b0;font-style:italic">%Find a path from node &#39;a&#39; to node &#39;f&#39;</span>
</span></span></code></pre></div><p>This will return one possible path.  To find all possible paths, you would need to modify the code to handle backtracking more carefully. This example illustrates how Prolog&rsquo;s declarative nature and backtracking can be used to solve problems involving search and exploration. Remember to consult your Prolog system&rsquo;s documentation for specifics on handling backtracking for this kind of problem.  The <code>\+</code> operator means &ldquo;not.&rdquo;  The <code>member</code> predicate checks for list membership.</p>

    
  </div>

  


  

  
  

<div class="single-pagination">
    <hr />

    <div class="flex">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/posts/beginners-guide-to-ada/">
                        Beginner&#39;s Guide to Ada
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
            <div class="single-pagination-container-next">
                <div class="single-pagination-text">
                    <a href="/posts/beginners-guide-to-d/">
                        Beginner&#39;s Guide to D
                    </a>
                </div>
                <div class="single-pagination-text">→</div>
            </div>
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


    </main>
  </div>

  <footer>
    

    
    
    
    <p>Made with ♥ in India</p>
    


  </footer>

  

</body>

<script>

  function isAuto() {
    return document.body.classList.contains("auto");
  }

  function setTheme() {
    if (!isAuto()) {
      return
    }

    document.body.classList.remove("auto");
    let cls = "light";
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      cls = "dark";
    }

    document.body.classList.add(cls);
  }

  function invertBody() {
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
  }

  if (isAuto()) {
    window.matchMedia('(prefers-color-scheme: dark)').addListener(invertBody);
  }

  setTheme();

</script>
<script>
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showSubResults: false, showImages: false });
    });
</script>
<script defer src="/js/copy-code.js"></script>
</html>